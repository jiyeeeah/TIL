# TIL

## 날짜: 2025-02-07

### 새로 배운 내용

#### synchronized와 volatile 키워드

- synchronized는 메서드나 블록에 적용하는 키워드이고, volatile은 변수에 적용하는 키워드
- 둘다 가시성 문제를 해결하기 위한 키워드
    
    > 가시성 문제란?
    > 
    > 한 스레드가 만든 변화를 다른 스레드에서 확인할 수 있는 것 <br>
    > 각 CPU 코어는 자신만의 캐시를 가지고 있어, 스레드가 각각 다른 캐시나 메모리를 바라보고 있는 경우 가시성 문제가 발생할 수 있다.
    > 
    
    |  | synchronized | volatile |
    | --- | --- | --- |
    | 범위 | 블록/메서드 전체의 모든 변수 | 해당 변수 |
    | 성능 | lock 획득 / 해제 비용이 추가되어 비용이 좀 든다. | 상대적으로 가벼움 |
    | 동기화 수준 | 상호 배제까지 보장 | 가시성만 보장 |
    
    > 상호 배제?
    > 
    > 한 시점에 하나의 스레드만 접근하는 것, 다른 스레드의 간섭을 완전히 차단한다.
- 원자성 보장 여부
    
    > 원자성?
    > 
    > 
    > 작업이 중간 상태를 가질 수 없다는 것 
    > 
    > ex. `count++`은 실제로 3단계의 작업임 (현재 값 읽기 / 1 증가 시키기 / 결과 저장하기)
    > 
    > 여기서 원자성이 깨지는 시나리오를 만들 수 있음
    > 
    > ```java
    > // 원자성이 깨지는 시나리오
    > // Thread A와 B가 동시에 실행된다고 가정
    > count = 0;  // 초기값
    > 
    > // Thread A
    > 1. 값 읽기 (count = 0)
    > 2. 1 증가 (temp = 1)
    >    // 여기서 컨텍스트 스위칭 발생
    > 
    > // Thread B
    > 1. 값 읽기 (count = 0)
    > 2. 1 증가 (temp = 1)
    > 3. 저장 (count = 1)
    > 
    > // Thread A (다시 실행)
    > 3. 저장 (count = 1)
    > 
    > // 최종 결과: count = 1
    > // 기대한 결과: count = 2
    > ```
    > 
    - `synchronized`는 블록 단위로 원자성을 보장함 ⇒ 그래서 복합 연산 (`count++`같은 연산)도 안전하게 수행 가능
    - volatile은 단일 변수의 읽기/쓰기만 원자성 보장함 ⇒ 그래서 복합 연산의 원자성은 보장 안됨

### 오늘의 회고

#### 데일리 스크럼

팀원들과 나누기 위해서 어제 한 일을 정리해보는데 생각보다 한 일이 너무 많아보여서 아주 뿌듯했다.
어제 저녁에 많이 쉬어서 거의 못했다고 생각했는데..!

- [사프] 회원가입시 닉네임 유효성 검사
- 동시성 / 병렬성 / 스케줄러 정리
- TIL 작성! 드디어 했다..! 배움일기도 작성했고..
- 못 들었던 화요일 수업(프로세스/스레드) 듣기
- 쉬기.. (쌓인 피로 풀기?)

진짜 많이 했다 ㅎㅎ 뿌듯~

#### 딥다이브

오늘은 아침부터 딥다이브를 먼저 했다.
나는 6번 문제를 맡아서 synchronized와 volatile 키워드의 차이에 대해 알아봤다.
이번주 수업을 많이 못 따라가서 제대로 정리도 못하고 내 스스로도 이해를 잘 못했다고 느꼈는데 막상 팀원들과 공유해보니 얘기하면서 스스로 깨닫게 되고 정리가 되었던 것 같다. 
다른 문제들에 대해서도 공부하고 팀원들의 발표를 들었다면 더 좋았겠지만 프로젝트도 조금 건드려야 했고, 무엇보다 피로가 쌓인건지 몸이 축축 처지고 의욕이 안 생겼던 것 같다. 많이 지친 느낌?

#### 지침.. 의욕 부족..

당연한거라고 생각한다. 이번주는 프로젝트랑 부트캠프를 병행하느라고 많이 지칠만 했다. ㅎㅎ 
그래서 그냥 받아들이고 좀 쉬엄쉬엄 했던 것 같다.
내일은 또 프로젝트를 달려야 하기 때문에 ^^